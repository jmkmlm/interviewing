### 二：计算机网络

1. 电路交换与分组交换的区别？ 优劣对比。

   ​                                                

2. ##### OSI有哪几层，会画出来，知道主要几层的各自作用。

   应用层，很简单，就是应用程序。这一层负责确定通信对象，并确保由足够的资源用于通信，这些当然都是想要通信的应用程序干的事情。为操作系统或网络应用程序提供访问网络服务的接口。
   应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。

   表示层，负责数据的编码、转化，确保应用层的正常工作。这一层，是将我们看到的界面与二进制间互相转化的地方，就是我们的语言与机器语言间的转化。数据的压缩、解压，加密、解密都发生在这一层。这一层根据不同的应用目的将数据处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。

   会话层，负责建立、维护、控制会话，区分不同的会话，以及提供单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务。我们平时所知的NFS，RPC,X Windows等都工作在这一层。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。

   传输层，负责分割、组合数据，实现端到端的逻辑连接。数据在上三层是整体的，到了这一层开始被分割，这一层分割后的数据被称为段(Segment)。三次握手(Three-way handshake)，面向连接(Connection-Oriented)或非面向连接(Connectionless-Oriented)的服务，流控(Flow control)等都发生在这一层。是第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。
   **在这一层，数据的单位称为数据段（segment）。**
   传输层协议的代表包括：TCP、UDP、SPX等

   网络层，负责管理网络地址，定位设备，决定路由。我们所熟知的IP地址和路由器就是工作在这一层。上层的数据段在这一层被分割，封装后叫做包(Packet)，包有两种，一种叫做用户数据包(Data packets)，是上层传下来的用户数据；另一种叫路由更新包(Route update packets)，是直接由路由器发出来的，用来和其他路由器进行路由信息的交换。负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互连等功能。
   **在这一层，数据的单位称为数据包（packet）。**
   网络层协议的代表包括：IP、IPX、RIP、OSPF等

   数据链路层，负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等。我们所熟知的MAC地址和交换机都工作在这一层。上层传下来的包在这一层被分割封装后叫做帧(Frame)。在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
   **在这一层，数据的单位称为帧（frame）。**
   数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等

   物理层，就是实实在在的物理链路，负责将数据以**比特流**的方式发送、接收，就不多说了。

3. TCP/IP有哪几层，会画出来，知道所有层数的作用，会列举各层主要的协议名称。

4. 硬件(MAC)地址的概念及作用。

5. ##### ARP协议的用途 及算法、在哪一层上会使用arp ？

   (1)首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。

   （2）当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。

   （3）当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。

   （4）源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

   广播发送ARP请求，单播发送ARP响应。

6. CRC冗余校验算法，反码和检验算法。

7. 如何实现透明传输。

8. ##### 知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）

   **物理层**：中继器（Repeater，也叫放大器），集线器，网线。

   **数据链路层**：网桥，交换机。

   **网络层**：路由器。

   **网关**：网络层以上的设备。

9. 路由表的内容。

10. 分组转发算法。

11. IP报文的格式，格式的各个字段的含义要理解。

12. MTU的概念，啥叫路径MTU？ MTU发现机制，TraceRoute(了解)。

13. RIP协议的概念 及算法。

14. ICMP协议的主要功能。

15. 组播和多播的概念，IGMP的用途。

16. Ping协议的实现原理，ping 命令格式。

17. ##### 子网划分的概念，子网掩码。

    子网掩码只有一个作用，就是将某个IP地址划分成[网络地址](http://www.netfoucs.com/article/u012422829/104939.html)和[主机地址](http://www.netfoucs.com/article/u012422829/104939.html)两部分。

    用于子网掩码的位数决定于可能的子网数目和每个子网的主机数目。

18. ##### IP地址的分类，如何划分的，及会计算各类地址支持的主机数。

    ![img](http://img.blog.csdn.net/20150414202657255)

19. DNS的概念，用途，DNS查询的实现算法。

20. ##### TCP与UDP的概念，相互的区别及优劣。

    TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。

    UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！

    |            | TCP          | UDP        |
    | ---------- | ------------ | ---------- |
    | 是否连接   | 面向连接     | 面向非连接 |
    | 传输可靠性 | 可靠         | 不可靠     |
    | 应用场合   | 传输大量数据 | 少量数据   |
    | 速度       | 慢           | 快         |


    ​              

21. UDP报文的格式，字段的意义。

22. TCP 报文的格式，字段的意义。

23. ##### TCP通过哪些措施，保证传输可靠？

    TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则。

    

24. ##### 三次握手，四次断开过程。

    “三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。 client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。

    **为什么4次断开？**

    因为TCP有个半关闭状态，假设A.B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，这个时候A不发数据，但是B如果发数据A还是要接受，这叫半关闭。然后B还要发给A连接释放报文，然后A发确认，所以是4次。

    在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是**全双工模式**，**接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。**

25. ##### TIME_WAIT状态的概念及意义。

    因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。

26. 滑动窗口协议 与 停止等待协议的区别。

27. ##### TCP的流量控制和拥塞控制实现原理(会画拥塞控制的典型图)。

    **防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。**拥塞控制所要做的都有一个**前提：网络能够承受现有的网络负荷。**拥塞控制是一个**全局性的过程**，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

     **拥塞控制代价**：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。

    **几种拥塞控制方法：**

    慢开始(slow-start )、拥塞避免(congestion avoidance )、快重传( fastretransmit )和快恢复( fastrecovery )。

    **慢开始和拥塞避免**

    发送方维持一个拥塞窗口cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。
        发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
        **慢开始算法**：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。

    每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。
    另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。
        为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：
        当 cwnd < ssthresh 时，使用上述的慢开始算法。
        当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
        当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。
    拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。
        无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。过程图如下：

    ![img](https://img-blog.csdn.net/20151223100408931?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

    

    **快速重传：**

    那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，快速重传做的事情有：

    1. 把ssthresh设置为cwnd的一半

    2. 把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)

       3.重新进入拥塞避免阶段。

    **快速恢复：**

    1. 当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3

    2. 再收到重复的ACK时，拥塞窗口增加1。

    3. 收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。

     

28. TCP的快速重传与快速恢复算法。

29. TFTP 与 FTP的区别。

30. 阻塞方式和非阻塞方式，阻塞connect与非阻塞connect。(比较难，有兴趣可以了解)

31. HTTP基本格式。（java程序员必须掌握）