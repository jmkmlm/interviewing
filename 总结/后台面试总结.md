### 一.计算机网络

##### 1.三次握手和四次挥手，以及第三次握手原因、第四次挥手原因、TIME_WAIT原因

```
a.三次握手：客户端第一次握手发送SYN给服务器链接指令；当服务器收到后，第二次握手发送给客户机确认指令，此时证明了客户机发送能力正常；当客户机收到确认指令后，证明服务器的发送和接受能力正常。然后客户机发送第三次握手确认连接成功，证明了客户机的接受能力正常。

b.第三次握手的原因：有两个原因，第一，当客户机收到服务器确认指令后，服务器并不难确认发送请求的客户机是否还存在，为了防止无效信息连接到服务器上，所以有了第三次握手。第二，确认客户机的接收能力正常。

c.四次挥手：客户机第一次发送FIN（不再发送数据）指令给服务器，客户机进入FIN_WAIT状态；当服务器收到后，第二次挥手发送ACK确认(同意关闭)，服务器第三次挥手再次发送FIN（不再发送数据）指令；当客户机收到后，进入TIME_WAIT状态，并第四次挥手发送ACK确认报文，并关闭连接。

d.四次挥手原因：第一次FIN是客户机不再发送数据，第二次ACK是服务器同意关闭连接，但是服务器仍然可以发送数据，第三次发送FIN确认服务器不再发送数据，第四次ACK是客户机同意关闭。

e.TIME_WAIT:接受服务器没有发送完的数据；确保网络中不存在无效连接。
```

##### 2.TCP拥塞控制算法

```
为了降低整个网络的拥塞程度。
拥塞窗口cwnd，传送单位为报文段，而实际发多少由发送方窗口决定。
1.慢开始与拥塞避免
	发送的最初执行慢开始，令cwnd=1，当收到确认后，将cwnd加倍，2,4,8，而当cwnd达到门限时，进入拥塞避免；每轮只将cwnd+1，若超时，门限=cwnd/2，重新满开始
2.快重传与快恢复
	在接收方，要求每次接收到报文段都应对最后一个已收到有序报文确认；例如收到M1 M2 此刻收到M4,应对M2确认
	在发送方收到三次重复却，那么只需快重传M3；
	在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复；令cwnd/2,直接进入拥塞避免；
```

<img src="C:\Users\HYT\AppData\Roaming\Typora\typora-user-images\1559614883555.png" height="50%" width="40%" align="left"><img src="C:\Users\HYT\AppData\Roaming\Typora\typora-user-images\1559614899059.png" height="50%" width="40%">



##### 3.Tcp、Udp特点

```
Tcp:1.面向连接2.可靠传输,基于数据流传输（顺序控制、重发控制）3.传输效率低4.点对点通信

流就是指不间断的数据结构,你可以把它想象成排水管道中的水流,当应用程序采用TCP发生消息时,虽然可以保证发送的顺序,但还是犹如没有任何间隔的数据流发送给接收端.

udp:1.无连接2.不可靠传输,基于数据报传输3.传输效率高4.多对多通信

数据报传输，不进行拆包和合并，因此传输层再收到对方的UDP包后回去掉首部后，将数据原封不动的交给应用进程。不进行校验，所以无法保证是否正确


TCP建立连接需要三次握手，讲了一下三次握手具体过程，有什么作用。
提到了TCP拥塞控制，以及相关问题。
```

##### 4.五层协议作用

```
应用层：为特定应用程序提供数据传输服务
传输层：为进程提供通用数据传输服务
网络层：为主机提供数据传输服务。网络层把传输层传递下来的用户数据或报文段封装成组；
数据链路层：主机之间有很多链路，链路层是为同一链路主机提供数据传输服务，链路层把网络层传下来的分组封装成帧。
物理层：尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感知不到差异


数据在向下传递过程中，需添加下层协议所需要的首部或尾部，而在向上过程不断拆开首部和尾部。
路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或应用程序服务。
```



### 二.HTTP

##### 1.状态码作用

```
301永久性重定向

302临时性重定向

502tomcat没有启动
```

##### 2.session、cookies、Token联系

```
1.起因：http是无状态协议，每次会话只是处于浏览状态，不保存任何信息，但后来随着电商网站发展，暴露出问题（购物车功能无法实现）
2.发展：随后，提出sessionID,服务器生成唯一sessionID，每次请求都包含这个id，这样服务器可以识别身份。
	但服务器压力增大，提出两种解决方案:①负责均衡，若请求的当前服务器挂了，就将sessionID复制到另外一台上。	②分布式集中认证，设置一台专门认证的机器，易发生单点故障
3.再发展：提出cookies，将sessionId交给客户机存，这样服务器每次只临时存对应id即可。但如果服务器处于分布式，每次请求转发的目的地都不同，导致sessionID无法验证成功。
4.最终：提出token，是一种服务器自由的加解密技术，它不存任何sessionid，只是每次把客户端发送过来id进行解密验证。
```



##### 3.get和post区别

```
a.可见性：get参数可见，post参数不可见

b.传输上：url拼接，post通过body传

c.缓冲性：get可缓冲，post不可缓冲

d.后退页面反应:get后退不影响，post后退重新提交

e.传输数据大小：get有限制2k，post无限制

f.安全性：post比get安全，但是抓包时候post可见
```

##### 4.请求转发和重定向

```
1、重定向是两次请求，转发是一次请求，因此转发的速度要快于重定向

2、重定向之后地址栏上的地址会发生变化，变化成第二次请求的地址，转发之后地址栏上的地址不会变化，还是第一次请求的地址

3、转发是服务器行为，重定向是客户端行为。重定向时浏览器上的网址改变 ,转发是浏览器上的网址不变

4、重定向是两次request，转发只有一次请求

5、重定向时的网址可以是任何网址，转发的网址必须是本站点的网址
```



##### 5.http1.0/1.1/2.0区别

```
a.长连接:http1.0需要使用参数才能建立长链接，http1.1默认长连接；

b.节约带宽:HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。

c.HOST域:
```

##### 6.http请求方法

```
GET 获取资源
HEAD 确认url有效性
POST 传输数据
PUT 上传文件
PATCH 对资源进行部分修改
DELETE 删除
OPTIONS 查询支持方法
CONNECT 与代理服务器建立通信隧道
TRACE 追踪路径
```

##### 7.HTTPS通信过程

```
1.浏览器将自己支持的一套加密规则发送给网站。 
2.网站将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 
3.浏览器获得证书之后浏览器要做以下工作： 
a) 验证证书的合法性 
b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码(对称密钥)，并用证书中提供的公钥加密。 
c) 使用对称密钥对消息进行加密，最后将之前生成的所有信息发送给网站。 
4.网站接收浏览器发来的数据之后要做以下的操作： 
a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 
b) 使用密码加密一段握手消息，发送给浏览器。 
5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。
```

<img src="C:\Users\HYT\AppData\Roaming\Typora\typora-user-images\1559628858628.png" width="50%" height="30%">

##### 8.http无状态解决会话跟踪方法

```
URL重写、隐藏表单域、Cookie、session
```

##### 9.一个页面从输入URL到页面加载显示完成，这个过程都发生什么？

```
1.DNS解析
	递归查询：客户机和服务器之间
	迭代查询：DNS服务器之间
2.发起tcp三次握手
3.若为https请求，则先进行证书验证，再发送以下信息：
	请求方法
	请求头
	请求协议
	请求url+ip
	首次请求没有cookie字段
4.返回请求状态码、第一次请求会返回Set-Cookie（name path expires domain secure）、实体内容
5.浏览器解析并渲染呈现给用户
```



### 三.操作系统

##### 1.进程和线程区别

```html
调度：线程在os中作为调度和分派的基本单位，进程中作为资源拥有的基本单位；

并发性：进程可以并发执行，一个进程的多个线程也可并发执行；

拥有的资源：进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源，本身基本不拥有系统资源，但可以访问隶属进程的资源；

系统开销：os在创建、撤销、切换进程时付出的开销显著大于线程。
```

##### 2.linux孤儿进程和僵尸进程

```
若子进程在父进程关闭时，没有关闭，则被称为孤儿进程，最后被init回收；

如果子进程退出，而父进程没有调用wait方法，那么子进程描述符就保存在系统中，称为僵尸进程，等待父进程关闭，成为孤儿进程，被init回收
```

##### 3.linux启动流程

```
BIOS加电自检，
disk读取启动加载器，
grub2获得系统控制器（1阶段加载MBR的446分区信息，1.5阶段加载boot驱动2阶段进入/boot加载内核），
加载grub2配置文件，启动target
```

##### 4.查看进程

```
实时查看top

查看所有进程内存 ps aus
```

##### 5.软连接和硬链接区别

```

```

##### 6.进程间通信方式

```

```

##### 7.进程有哪些状态

```

```

##### 8.如何查看堆内存信息

##### 9.OOM问题怎么排除



##### 10.出现死锁怎么排查



### 四.数据结构

##### 1.排序算法、单例算法

##### 2.单链表逆制

##### 3.完全二叉树的i层节点数

##### 4.两个有序数组，选出两个和一定

##### 5.二叉树遍历（循环和递归）、及高度

##### 6.镜像二叉树

##### 7.堆排序过程

##### 8.链表是否有环

### 五.MySql

##### 1.索引的实现以及和hash索引区别，以及和主键区别以及存储引擎的索引区别

```
二叉树--hash树--红黑树--B-Tree树--B+Tree树
红黑树：自平衡二叉查找树（高度影响查询效率-key从左到右递增）
B-Tree:在红黑树基础上，一个节点存多个数据（一次io大小）
B+Tree:非叶子结点只存key，不存数据（横向存储能力提升，树高度小）；叶子结点顺序访问指针，存数据；
```

##### 2.优化

```
设计优化

查询优化
```

##### 3.事务的隔离级别及默认级别

并发事务带来的问题：

1.更新丢失：两个事务操作相同的数据，后提交的覆盖先提交事务

2.脏读：事务A读取事务B的已修改未提交数据，若B回滚，A读出新的数据，与之前读的不一致

3.不可重复读：事务A读取了事务B已提交**修改**的数据

4.幻读：事务读取到了事务B提交**新增**的数据

|                                 | 脏读                        |                 不可重复读                 | 幻读   |
| ------------------------------- | --------------------------- | :----------------------------------------: | ------ |
| 读未提交READ-UnCommited         |                             |                                            |        |
| 读已提交Read-commited           | 不出现（事务A读取数据不变） |                                            |        |
| 可重复读repeatable-read（默认） | 不出现                      | 不出现（事务B在A修改提交后数据仍不变MVCC） |        |
| 可串行化                        | 不出现                      |                   不出现                   | 不出现 |

##### 4.事务ACID的4个特性

```
A原子性：不可分割的执行

C一致性：执行前后双方总金额保持一致

I隔离性：事务内部和事务操作隔离

D持久性：永久性修改 
```

##### 5.乐观锁和悲观锁实现



##### 6.mysql锁并发，加锁机制

##### 7.分库和分表设计，以及带来分布式困境与对应策略，分表垂直切分水平切分怎么选择

##### 8.基本的写sql能力：灵活使用join,groupby,order by以及常见的聚合函数

##### 9.主从复制

##### 10.数据库查的慢原因

```
a.没有索引

b.查询语句不好

c.网络慢、内存不足、I/O吞吐量小

解决：把数据、日志、索引放到不同I/O设备上，横向、纵向切分表，减少表尺寸
```

##### 11.MVCC

```
多版本并发控制：保存数据在某个时间点的快照来实现的，保证每个事务看到的数据都是一致的。
```

##### 12.缓冲一致性

### 六.Java基础

##### 1.volatile使用？

##### 2.可重入锁理解以及不可重入锁区别？

##### 3.Synchronized是不是可重入锁？

##### 4.synchronized与Lock的区别、实现原理、CAS的实现与使用？



##### 5.HashMap底层实现，线程安全实现

```txt
数组+单链表，Node内部类，add过程，hash冲突办法，扩容，三种集合视图。
线程安全HashTable、ConcurrentHashMap以及Collections静态方法，SynchronizedMap对HashMap封装。以及这三种效率区别。
```

##### 6.JVM内存管理，GC算法，HostSpot里的垃圾回收器，类加载

```
a.jvm分为五个区：堆、方法区、方法栈、本地方法栈、程序计数器；
b.哪些是线程共享，哪些是独享，每个区存放什么？
	方法区存放类信息、常量、static变量。
c.怎么判断对象需要被GC，GC方法，MinorGC和FullGC？
	可达性分析判断对象是否需要被GC，底层利用了有向图遍历，到对象不可达，就要被回收；
	MinorGC:主要回收新生代，周期短，执行频繁
	FullGC：主要回收老年代和新生代，老年代生成周期长，故很少执行
d.HostSpot GC算法以及7种垃圾回收器，主要讲CMS和G1回收器。
	GC算法:1.标记-清除2.复制3.标记-压缩4.分代收集
	CMS回收器：获取最短停顿时间为目标的回收器（标记-清楚）
	G1回收器：标记-压缩
e.类加载器：bootStrap classloader-ExtClassloader AppClassLoader,父类委托机制
f.类加载流程：
1.准备：通过类的全限定名来获取其二进制字节流，将二进制字节流所代表静态存储转为方法区运行的数据结构，在堆中生成类对象，作为对方法区数据访问入口；
2.链接（验证-准备-解析）
验证：对文件格式、元数据、字节码、符号引用验证
准备：为类的静态变量分配内存
解析：把符号引用转为直接饮用
3.初始化
为类静态变量赋初值

```

##### 7.Java IO、NIO，java中有没有异步IO

```
java io是同步阻塞，拿read方法举例。
NIO是已同步非阻塞，讲selector中select方法轮询实现多路复用IO。
unix中有异步io
```

##### 8.设计一个线程池

```
仿照ThreadPoolExecutor，核心池、创建线程可以工厂方法模式来设计，线程池状态、阻塞队列、拒绝策略
```

##### 9.set和list区别

```
set不可重复、无序；hashset、TreeSet

list可重复，有序；hashlist、ArrayList、vector
```

##### 10.string，stringbuffer，StringBuilder

##### 11.Array与ArrayList的区别，ArrayList与LinkedList的区别

##### 12.为什么重写equals和hashcode

```
不重写的话，默认继承Object的方法，而Object是取对象地址的hash和equals。
```

##### 13.多线程使用场景

```
a.高并发：当系统接收实现用户请求的高并发，用线程实现；

b.线程后台处理大任务：一个程序是线性执行，如果程序执行完要大量时间，而主线程必须等待他执行完，这时采用线程可以把大任务交给后台执行，主线程继续。

c.大任务：大任务处理比较费时，可以采用多线程并行处理
```

##### 14.重载和重写

```
重载：根据静态类型来确定（编译器已知）--静态多分派
重写：首先确认运行期数据类型（从底向上查找），若确认将符号引用解析到不同的直接引用上。--动态单分派
```



### 七.Java框架

##### 1.MVC模式



##### 2.IOC、AOP实现，ioc如何避免管理bean循环依赖

```
循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。

Spring的单例对象的初始化主要分为三步： 
（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象
（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充
（3）initializeBean：调用spring xml中的init 方法。
循环依赖主要发生在第一、第二部。也就是构造器循环依赖和field循环依赖。

对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。
这三级缓存分别指： 
	singletonFactories:单例对象工厂
	earlySingletonObjects:提前曝光的单例对象的Cache 
	singletonObjects:存完全初始化好的bean
	
解决方案：
在字段上使用@Autowired注解，让Spring决定在合适的时机注入。
用基于setter方法的依赖注射取代基于构造函数的依赖注入来解决循环依赖
```



##### 3.常用设计模式

```
单例模式：getRuntime()
工厂方法模式:ThreadFacory()
观察者模式:java.util
```

##### 4.springmvc一次请求过程

```
1.用户向服务器发送请求，请求被Spring前端控制Servlet DispatcherServlet捕获
2.DispatcherServlet对请求url进行解析，得到请求资源标识符uri，然后根据该uri，调用HandlerMapping获得该handler配置的所有相关对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExcutionChain对象的形式返回（查找handler）
3.DispatcherServlet根据获得的Hander，选择一个合适的HandlerAdapter。提取Request中的模型数据，填充Handler入参，开始执行Handler（controller），Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象
4.DispatcherServlet根据返回的ModelAndView，选择一个合适的viewResolver（必须是已经注册到Spring容器中的ViewResolver）
5.通过ViewResolver结合Model和View，来渲染视图，DispatcherServlet将渲染结果返回给客户端（渲染返回）
```

##### 5.mybatis原理

##### 6.spring原理